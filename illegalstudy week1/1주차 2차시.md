아래의 코드에서 표현식인 부분과 표현식이 아닌 부분에 대해서 구분하시오.

``` JS

var x;                //표현식 (값 생성
x=100;                //표현식 (값을 참조
//*
-----------------------------
*/
var a = y = 100;      //표현식 (값을 참조
console.log(a);       //표현식이 아님
//*
-----------------------------
*/
var foo = var x;      //표현식 (값을 참

```




#그렇다면 위에 설명과 같이 다 실수로 측정한다면 2진수, 8진수, 16진수를 출력하면 어떤식으로 될까?
``` JS
var binary = 0b01000001;
var octal = 0o101;
var hex = 0x41;
console.log(binary,octal,hex);
if(binary === hex) console.log(true);
if(binary === octal) console.log(true)
```

65 65 65
true true 라는 값이 나오며, 모든 값이 다 실수로 측정되어 ===로 비교해도 true가 나오는듯함.



원시 타입은 쉽게 말해, 정수, 실수, 문자, 논리 리터럴등의 실제 데이터 값을 저장하는 타입이고,

참조 타입은 객체(Object)의 번지를 참조(주소를 저장)하는 타입으로 메모리 번지 값을 통해 객체를 참조하는 타입이다.

'==' 연산자를 이용하여 서로 다른 유형의 두 변수의 '값' 비교
'==='는 엄격한 비교를 하는 것으로 알려져 있다. '값&자료형' -> true).
***




#다 실수라면 아래의 비교문의 결과는 어떻게 나올까?

``` JS
console.log(1 === 1.0);
console.log(4 / 2);
console.log(3 / 2)
```
true
2
1.5 // 실수나누기 실수는 실수임!!!!!
---

# 위에 세가지를 console을 이용하여 도출해보세요.

Infinity는 number -Infinity 는 number, typeof NaN도 number이다.

NaN은 Not a Number이라는뜻. 수학 연산에서 유효하지 않은 값을 반환할 때 반환된다. 유효하지 않은
연산인데도 Number 타입으로 반환이 된다.


# 만약 NaN이 아닌 nan, NAN 같이 변수에 대입하면 어떤 식으로 나올까요?
대소문자 구분하기 때문에 undefined로 나온다.

---

# “” 안의 ‘’(single quote)은 뭘로 인식되고 ‘’(single quote) 안의 “”은 뭘로 인식될까
var a = "이거랑'이거랑'";
var b = '꽃게랑"꽃게랑"';



---
//문자열은 문자열 연산자 + 를 통해서 연결이 가능함

#그렇다면 아래의 코드는 어떤식으로 다를까?
``` JS
console.log(`a + b = ${1 + 2}`);
console.log('a + b = ${1 + 2}');
```
``` JS
a + b = 3
a + b = ${1 + 2}
```
---


# 의도적 부재를 왜 사용할까?
쓰레기값이 들어가 있으면 의도치 않은 오류를 발생할 수 있는데, 이를 방지하기 위함이다.

# 과연 아래의 사용법이 옳은 선택일까? 다른 방법으로 변수를 소멸시키는게 좋지않을까? 

var night = 'Turtle';
// 밑의 선언으로 인해 night는 더이상 터틀이라는 값을 참조하지 않으며 언젠가 gc에 없어져버린다.
night = null;

기비지 콜렉터는 랜덤한 타이밍에 발생하기때문에 즉시 변수를 소멸시키고싶다면 좋은 방법이 아닐 수 있다. 더 좋은 방법은 음...

---




# ECMAScript 사양은 문자열과 숫자 타입 외에는 명시적으로 규정하고 있지 않은데 그렇다면 해당 데이터 타입들 외에는 어떤 식으로 계산되고 있는가?




# 심벌 테이블 이라는 뜻을 알아보시오
Symbol table
1997년 자바스크립트가 ECMAScript로 처음 표준화된 이래로 자바스크립트는 6개의 타입을 가지고 있었다.
심볼(symbol)은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다.
 It is collections of key-value pairs. 키와 값의 쌍의 모음이다.

// https://github.com/wessberg/symboltable

--- 


# 대표적인 동적/정적 언어를 조사해보시오
대표적인 동적언어 : JavaScript,Ruby,Python,SmallTalk
대표적인 정적언어 : C,C#,C++,Java 

정적언어는 변수에 들어갈 값의 형태에 따라 자료형을 지정해주어야 한다.
컴파일 시에 자료형에 맞지 않은 값이 들어있으면 컴파일 에러가 발생한다.
장점은 컴파일 시에 타입에 대한 정보를 결정하기 때문에 속도가 올라가고 타입 에러로 인한 문제점을 초기에 발견할 수 있어 타입의 안정성이 올라간다.

동적언어는 컴파일 시 자료형을 정하는 것이 아니고 실행 시에 결정한다. 타입 없이 변수만 선언하여 값을 지정할 수 있다.
장점은 런타임까지 타입에 대한 결정을 끌고 갈 수 있기 때문에 많은 선택의 여지가 있다.
단점은 인터프리터 언어는 배우기도 쉽지만 실행 도중에 변수에 예상치 못한 타입이 들어와 타입에러를 뿜는 경우가 생길 수 있다.

---

# 아래의 코드를 실행하시면 됩니다.
```JS
var a = '1';
console.log(+a, typeof +a);
console.log(a, typeof a);
a = true;
console.log(+a, typeof +a);
console.log(a, typeof a);
a = false;
console.log(+a, typeof +a);
console.log(a, typeof a);
a = 'Hi';
console.log(+a, typeof +a);
console.log(a, typeof a);
```

``` JS
1 'number'
VM144:3 1 string
VM144:5 1 'number'
VM144:6 true 'boolean'
VM144:8 0 'number'
VM144:9 false 'boolean'
VM144:11 NaN 'number'
VM144:12 Hi string
```


# 암묵적 타입 변환 또는 타입 강제 변환에 대해서 알아보시오
명시적 타입 변환은 개발자가 의도적으로 타입을 변환하는 것으로, 타입 캐스팅 이라고도 한다.

그에 반대로 암묵적 타입 변환은 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되는 것이다. 타입 강제 변환(Type Coercion)이라고 한다.

https://jungwoney.tistory.com/12

---
# 아래의 비교가 뭐가 다른지 알아보시오.
5 == 5;  //true
5 == '5'; //true



==는 x와 y의 값이 같다는 것을 비교하는 것이고

// ================================================
5 === 5; //true
5 === '5'; //false

===는 x와 y의 값,그리고 타입도 같은지 비교하는것이다
// ================================================
'0' == '';  //false   //문자열 0과 빈 문자열은 다르다고 판단
0 == ''; //true  //==으로 비교시 0과 ''같다고 판단
0 == '0'; //true   //문자열0과 숫자0을 같다고 판단
// ================================================
false == 'false'; // false    //문자열 false와 false는 다름
false == '0'; // true   //false와 문자열 0은 같다고 판단
false == null; // false  //false와 null은 다르다고 판단
false == undefined; // false // null도 undefined라 false와 다르다고 판단


// ---
NaN === NaN //false    //NaN은 다른 모든 값과 비교(==, !=, ===, !==)했을 때에도 같지 않고, 다른 NaN과도 같지 않다.
0 == -0 // true
0 === -0 // true

 
==으로 비교 시, 0과 false 같은 경우도 ""와 같다고 판단될 수 있습니다. 반면에 null이나 undefined는 다르다고 평가됩니다

https://velog.io/@pul8219/JS-NaN-isNaN%EA%B3%BC-Number.isNaN%EC%9D%98-%EC%B0%A8%EC%9D%B4     - NaN은NaN과 같지않다

https://codechacha.com/ko/javascript-check-empty-string/

https://velog.io/@cada/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-0%EC%9D%B4-true%EC%9D%B8-%EC%9D%B4%EC%9C%A0

``` JS
 - 0 === 0 ;
Object.is(-0,0) 
NaN === NaN;
Object.is(NaN,NaN);
의 결과가 왜 다를까?
```

# 위에 있는 반환 값을 다 나타내보시오.
예시 )
typeof 1
