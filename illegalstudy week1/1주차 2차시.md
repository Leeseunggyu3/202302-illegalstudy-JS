아래의 코드에서 표현식인 부분과 표현식이 아닌 부분에 대해서 구분하시오.

``` JS

var x;                //표현식 (값 생성
x=100;                //표현식 (값을 참조
//*
-----------------------------
*/
var a = y = 100;      //표현식 (값을 참조
console.log(a);       //표현식이 아님
//*
-----------------------------
*/
var foo = var x;      //표현식 (값을 참

```




#그렇다면 위에 설명과 같이 다 실수로 측정한다면 2진수, 8진수, 16진수를 출력하면 어떤식으로 될까?
``` JS
var binary = 0b01000001;
var octal = 0o101;
var hex = 0x41;
console.log(binary,octal,hex);
if(binary === hex) console.log(true);
if(binary === octal) console.log(true)
```

65 65 65
true true 라는 값이 나오며, 모든 값이 다 실수로 측정되어 ===로 비교해도 true가 나오는듯함.



원시 타입은 쉽게 말해, 정수, 실수, 문자, 논리 리터럴등의 실제 데이터 값을 저장하는 타입이고,

참조 타입은 객체(Object)의 번지를 참조(주소를 저장)하는 타입으로 메모리 번지 값을 통해 객체를 참조하는 타입이다.

'==' 연산자를 이용하여 서로 다른 유형의 두 변수의 '값' 비교
'==='는 엄격한 비교를 하는 것으로 알려져 있다. '값&자료형' -> true).
***




#다 실수라면 아래의 비교문의 결과는 어떻게 나올까?

``` JS
console.log(1 === 1.0);
console.log(4 / 2);
console.log(3 / 2)
```
true
2
1.5 // 실수나누기 실수는 실수임!!!!!
---

# 위에 세가지를 console을 이용하여 도출해보세요.

Infinity는 number -Infinity 는 number, typeof NaN도 number이다.

NaN은 Not a Number이라는뜻. 수학 연산에서 유효하지 않은 값을 반환할 때 반환된다. 유효하지 않은
연산인데도 Number 타입으로 반환이 된다.


# 만약 NaN이 아닌 nan, NAN 같이 변수에 대입하면 어떤 식으로 나올까요?
대소문자 구분하기 때문에 undefined로 나온다.

---

# “” 안의 ‘’(single quote)은 뭘로 인식되고 ‘’(single quote) 안의 “”은 뭘로 인식될까
var a = "이거랑'이거랑'";
var b = '꽃게랑"꽃게랑"';



---
//문자열은 문자열 연산자 + 를 통해서 연결이 가능함

#그렇다면 아래의 코드는 어떤식으로 다를까?
console.log(`a + b = ${1 + 2}`);
console.log('a + b = ${1 + 2}');

a + b = 3
a + b = ${1 + 2}

---


# 의도적 부재를 왜 사용할까?
쓰레기값이 들어가 있으면 의도치 않은 오류를 발생할 수 있는데, 이를 방지하기 위함이다.

# 과연 아래의 사용법이 옳은 선택일까? 다른 방법으로 변수를 소멸시키는게 좋지않을까? 

var night = 'Turtle';
// 밑의 선언으로 인해 night는 더이상 터틀이라는 값을 참조하지 않으며 언젠가 gc에 없어져버린다.
night = null;

기비지 콜렉터는 랜덤한 타이밍에 발생하기때문에 즉시 변수를 소멸시키고싶다면 좋은 방법이 아닐 수 있다.

# 대표적인 동적/정적 언어를 조사해보시오



# ECMAScript 사양은 문자열과 숫자 타입 외에는 명시적으로 규정하고 있지 않은데 그렇다면 해당 데이터 타입들 외에는 어떤 식으로 계산되고 있는가?

# 심벌 테이블 이라는 뜻을 알아보시오



# 아래의 코드를 실행하시면 됩니다.
var a = '1';
console.log(+a, typeof +a);
console.log(a, typeof a);
a = true;
console.log(+a, typeof +a);
console.log(a, typeof a);
a = false;
console.log(+a, typeof +a);
console.log(a, typeof a);
a = 'Hi';
console.log(+a, typeof +a);
console.log(a, typeof a);



# 암묵적 타입 변환 또는 타입 강제 변환에 대해서 알아보시오



# 아래의 비교가 뭐가 다른지 알아보시오.
5 == 5;
5 == '5';
// ================================================
5 === 5;
5 === '5';
// ================================================
'0' == '';
0 == '';
0 == '0';
// ================================================
false == 'false';
false == '0';
false == null;
false == undefined;
// ---
NaN === NaN
0 == -0
0 === -0




# - 0 === 0 ;
Object.is(-0,0) 
NaN === NaN;
Object.is(NaN,NaN);
의 결과가 왜 다를까?


# 위에 있는 반환 값을 다 나타내보시오.
예시 )
typeof 1
